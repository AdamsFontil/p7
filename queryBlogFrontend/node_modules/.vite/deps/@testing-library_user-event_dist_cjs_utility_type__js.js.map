{
  "version": 3,
  "sources": ["../../@testing-library/user-event/dist/esm/utils/dataTransfer/Clipboard.js", "../../@testing-library/user-event/dist/esm/utils/keyDef/readNextDescriptor.js", "../../@testing-library/user-event/dist/esm/keyboard/index.js", "../../@testing-library/user-event/dist/esm/utils/edit/isContentEditable.js", "../../@testing-library/user-event/dist/esm/utils/misc/isElementType.js", "../../@testing-library/user-event/dist/esm/utils/click/isClickableInput.js", "../../@testing-library/user-event/dist/esm/utils/edit/isEditable.js", "../../@testing-library/user-event/dist/esm/utils/focus/selection.js", "../../@testing-library/user-event/dist/esm/document/UI.js", "../../@testing-library/user-event/dist/esm/event/selection/getTargetTypeAndSelection.js", "../../@testing-library/user-event/dist/esm/event/selection/setSelection.js", "../../@testing-library/user-event/dist/esm/event/selection/setSelectionRange.js", "../../@testing-library/user-event/dist/esm/utility/type.js"],
  "sourcesContent": ["import { getWindow } from '../misc/getWindow.js';\nimport { readBlobText } from './Blob.js';\nimport { createDataTransfer, getBlobFromDataTransferItem } from './DataTransfer.js';\n\n// Clipboard is not available in jsdom\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n// MDN lists string|Blob|Promise<Blob|string> as possible types in ClipboardItemData\n// lib.dom.d.ts lists only Promise<Blob|string>\n// https://developer.mozilla.org/en-US/docs/Web/API/ClipboardItem/ClipboardItem#syntax\nfunction createClipboardItem(window, ...blobs) {\n    const dataMap = Object.fromEntries(blobs.map((b)=>[\n            typeof b === 'string' ? 'text/plain' : b.type,\n            Promise.resolve(b)\n        ]));\n    // use real ClipboardItem if available\n    /* istanbul ignore if */ if (typeof window.ClipboardItem !== 'undefined') {\n        return new window.ClipboardItem(dataMap);\n    }\n    return new class ClipboardItem {\n        get types() {\n            return Array.from(Object.keys(this.data));\n        }\n        async getType(type) {\n            const value = await this.data[type];\n            if (!value) {\n                throw new Error(`${type} is not one of the available MIME types on this item.`);\n            }\n            return value instanceof window.Blob ? value : new window.Blob([\n                value\n            ], {\n                type\n            });\n        }\n        constructor(d){\n            _define_property(this, \"data\", undefined);\n            this.data = d;\n        }\n    }(dataMap);\n}\nconst ClipboardStubControl = Symbol('Manage ClipboardSub');\nfunction createClipboardStub(window, control) {\n    return Object.assign(new class Clipboard extends window.EventTarget {\n        async read() {\n            return Array.from(this.items);\n        }\n        async readText() {\n            let text = '';\n            for (const item of this.items){\n                const type = item.types.includes('text/plain') ? 'text/plain' : item.types.find((t)=>t.startsWith('text/'));\n                if (type) {\n                    text += await item.getType(type).then((b)=>readBlobText(b, window.FileReader));\n                }\n            }\n            return text;\n        }\n        async write(data) {\n            this.items = data;\n        }\n        async writeText(text) {\n            this.items = [\n                createClipboardItem(window, text)\n            ];\n        }\n        constructor(...args){\n            super(...args), _define_property(this, \"items\", []);\n        }\n    }(), {\n        [ClipboardStubControl]: control\n    });\n}\nfunction isClipboardStub(clipboard) {\n    return !!(clipboard === null || clipboard === undefined ? undefined : clipboard[ClipboardStubControl]);\n}\nfunction attachClipboardStubToView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        return window.navigator.clipboard[ClipboardStubControl];\n    }\n    const realClipboard = Object.getOwnPropertyDescriptor(window.navigator, 'clipboard');\n    let stub;\n    const control = {\n        resetClipboardStub: ()=>{\n            stub = createClipboardStub(window, control);\n        },\n        detachClipboardStub: ()=>{\n            /* istanbul ignore if */ if (realClipboard) {\n                Object.defineProperty(window.navigator, 'clipboard', realClipboard);\n            } else {\n                Object.defineProperty(window.navigator, 'clipboard', {\n                    value: undefined,\n                    configurable: true\n                });\n            }\n        }\n    };\n    stub = createClipboardStub(window, control);\n    Object.defineProperty(window.navigator, 'clipboard', {\n        get: ()=>stub,\n        configurable: true\n    });\n    return stub[ClipboardStubControl];\n}\nfunction resetClipboardStubOnView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].resetClipboardStub();\n    }\n}\nfunction detachClipboardStubFromView(window) {\n    if (isClipboardStub(window.navigator.clipboard)) {\n        window.navigator.clipboard[ClipboardStubControl].detachClipboardStub();\n    }\n}\nasync function readDataTransferFromClipboard(document) {\n    const window = document.defaultView;\n    const clipboard = window === null || window === undefined ? undefined : window.navigator.clipboard;\n    const items = clipboard && await clipboard.read();\n    if (!items) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n    const dt = createDataTransfer(window);\n    for (const item of items){\n        for (const type of item.types){\n            dt.setData(type, await item.getType(type).then((b)=>readBlobText(b, window.FileReader)));\n        }\n    }\n    return dt;\n}\nasync function writeDataTransferToClipboard(document, clipboardData) {\n    const window = getWindow(document);\n    const clipboard = window.navigator.clipboard;\n    const items = [];\n    for(let i = 0; i < clipboardData.items.length; i++){\n        const dtItem = clipboardData.items[i];\n        const blob = await getBlobFromDataTransferItem(window, dtItem);\n        items.push(createClipboardItem(window, blob));\n    }\n    const written = clipboard && await clipboard.write(items).then(()=>true, // Can happen with other implementations that e.g. require permissions\n    /* istanbul ignore next */ ()=>false);\n    if (!written) {\n        throw new Error('The Clipboard API is unavailable.');\n    }\n}\nconst g = globalThis;\n/* istanbul ignore else */ if (typeof g.afterEach === 'function') {\n    g.afterEach(()=>resetClipboardStubOnView(globalThis.window));\n}\n/* istanbul ignore else */ if (typeof g.afterAll === 'function') {\n    g.afterAll(()=>detachClipboardStubFromView(globalThis.window));\n}\n\nexport { attachClipboardStubToView, createClipboardItem, detachClipboardStubFromView, readDataTransferFromClipboard, resetClipboardStubOnView, writeDataTransferToClipboard };\n", "var bracketDict = /*#__PURE__*/ function(bracketDict) {\n    bracketDict[\"{\"] = \"}\";\n    bracketDict[\"[\"] = \"]\";\n    return bracketDict;\n}(bracketDict || {});\n/**\n * Read the next key definition from user input\n *\n * Describe key per `{descriptor}` or `[descriptor]`.\n * Everything else will be interpreted as a single character as descriptor - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * A previously pressed key can be released per `{/descriptor}`.\n * Keeping the key pressed can be written as `{descriptor>}`.\n * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.\n * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.\n */ function readNextDescriptor(text, context) {\n    let pos = 0;\n    const startBracket = text[pos] in bracketDict ? text[pos] : '';\n    pos += startBracket.length;\n    const isEscapedChar = new RegExp(`^\\\\${startBracket}{2}`).test(text);\n    const type = isEscapedChar ? '' : startBracket;\n    return {\n        type,\n        ...type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context)\n    };\n}\nfunction readPrintableChar(text, pos, context) {\n    const descriptor = text[pos];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: false,\n        releaseSelf: true,\n        repeat: 1\n    };\n}\nfunction readTag(text, pos, startBracket, context) {\n    var _text_slice_match, _text_slice_match1;\n    const releasePreviousModifier = text[pos] === '/' ? '/' : '';\n    pos += releasePreviousModifier.length;\n    const escapedDescriptor = startBracket === '{' && text[pos] === '\\\\';\n    pos += Number(escapedDescriptor);\n    const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\\w+|^[^}>/]/ : /^\\w+/)) === null || _text_slice_match === undefined ? undefined : _text_slice_match[0];\n    assertDescriptor(descriptor, text, pos, context);\n    pos += descriptor.length;\n    var _text_slice_match_;\n    const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\\d+/)) === null || _text_slice_match1 === undefined ? undefined : _text_slice_match1[0]) !== null && _text_slice_match_ !== undefined ? _text_slice_match_ : '';\n    pos += repeatModifier.length;\n    const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';\n    pos += releaseSelfModifier.length;\n    const expectedEndBracket = bracketDict[startBracket];\n    const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';\n    if (!endBracket) {\n        throw new Error(getErrorMessage([\n            !repeatModifier && 'repeat modifier',\n            !releaseSelfModifier && 'release modifier',\n            `\"${expectedEndBracket}\"`\n        ].filter(Boolean).join(' or '), text[pos], text, context));\n    }\n    pos += endBracket.length;\n    return {\n        consumedLength: pos,\n        descriptor,\n        releasePrevious: !!releasePreviousModifier,\n        repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,\n        releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)\n    };\n}\nfunction assertDescriptor(descriptor, text, pos, context) {\n    if (!descriptor) {\n        throw new Error(getErrorMessage('key descriptor', text[pos], text, context));\n    }\n}\nfunction hasReleaseSelf(releaseSelfModifier, repeatModifier) {\n    if (releaseSelfModifier) {\n        return releaseSelfModifier === '/';\n    }\n    if (repeatModifier) {\n        return false;\n    }\n}\nfunction getErrorMessage(expected, found, text, context) {\n    return `Expected ${expected} but found \"${found !== null && found !== undefined ? found : ''}\" in \"${text}\"\n    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}\n    for more information about how userEvent parses your input.`;\n}\n\nexport { readNextDescriptor };\n", "import '../utils/dataTransfer/Clipboard.js';\nimport { wait } from '../utils/misc/wait.js';\nimport { parseKeyDef } from './parseKeyDef.js';\n\nasync function keyboard(text) {\n    const actions = parseKeyDef(this.config.keyboardMap, text);\n    for(let i = 0; i < actions.length; i++){\n        await wait(this.config);\n        await keyboardAction(this, actions[i]);\n    }\n}\nasync function keyboardAction(instance, { keyDef, releasePrevious, releaseSelf, repeat }) {\n    const { system } = instance;\n    // Release the key automatically if it was pressed before.\n    if (system.keyboard.isKeyPressed(keyDef)) {\n        await system.keyboard.keyup(instance, keyDef);\n    }\n    if (!releasePrevious) {\n        for(let i = 1; i <= repeat; i++){\n            await system.keyboard.keydown(instance, keyDef);\n            if (i < repeat) {\n                await wait(instance.config);\n            }\n        }\n        // Release the key only on the last iteration on `state.repeatKey`.\n        if (releaseSelf) {\n            await system.keyboard.keyup(instance, keyDef);\n        }\n    }\n}\nasync function releaseAllKeys(instance) {\n    for (const k of instance.system.keyboard.getPressedKeys()){\n        await instance.system.keyboard.keyup(instance, k);\n    }\n}\n\nexport { keyboard, releaseAllKeys };\n", "//jsdom is not supporting isContentEditable\nfunction isContentEditable(element) {\n    return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');\n}\n/**\n * If a node is a contenteditable or inside one, return that element.\n */ function getContentEditable(node) {\n    const element = getElement(node);\n    return element && (element.closest('[contenteditable=\"\"]') || element.closest('[contenteditable=\"true\"]'));\n}\nfunction getElement(node) {\n    return node.nodeType === 1 ? node : node.parentElement;\n}\n\nexport { getContentEditable, isContentEditable };\n", "function isElementType(element, tag, props) {\n    if (element.namespaceURI && element.namespaceURI !== 'http://www.w3.org/1999/xhtml') {\n        return false;\n    }\n    tag = Array.isArray(tag) ? tag : [\n        tag\n    ];\n    // tagName is uppercase in HTMLDocument and lowercase in XMLDocument\n    if (!tag.includes(element.tagName.toLowerCase())) {\n        return false;\n    }\n    if (props) {\n        return Object.entries(props).every(([k, v])=>element[k] === v);\n    }\n    return true;\n}\n\nexport { isElementType };\n", "import { isElementType } from '../misc/isElementType.js';\n\nvar clickableInputTypes = /*#__PURE__*/ function(clickableInputTypes) {\n    clickableInputTypes[\"button\"] = \"button\";\n    clickableInputTypes[\"color\"] = \"color\";\n    clickableInputTypes[\"file\"] = \"file\";\n    clickableInputTypes[\"image\"] = \"image\";\n    clickableInputTypes[\"reset\"] = \"reset\";\n    clickableInputTypes[\"submit\"] = \"submit\";\n    clickableInputTypes[\"checkbox\"] = \"checkbox\";\n    clickableInputTypes[\"radio\"] = \"radio\";\n    return clickableInputTypes;\n}(clickableInputTypes || {});\nfunction isClickableInput(element) {\n    return isElementType(element, 'button') || isElementType(element, 'input') && element.type in clickableInputTypes;\n}\n\nexport { isClickableInput };\n", "import { isElementType } from '../misc/isElementType.js';\nimport { isContentEditable } from './isContentEditable.js';\n\nfunction isEditable(element) {\n    return isEditableInputOrTextArea(element) && !element.readOnly || isContentEditable(element);\n}\nvar editableInputTypes = /*#__PURE__*/ function(editableInputTypes) {\n    editableInputTypes[\"text\"] = \"text\";\n    editableInputTypes[\"date\"] = \"date\";\n    editableInputTypes[\"datetime-local\"] = \"datetime-local\";\n    editableInputTypes[\"email\"] = \"email\";\n    editableInputTypes[\"month\"] = \"month\";\n    editableInputTypes[\"number\"] = \"number\";\n    editableInputTypes[\"password\"] = \"password\";\n    editableInputTypes[\"search\"] = \"search\";\n    editableInputTypes[\"tel\"] = \"tel\";\n    editableInputTypes[\"time\"] = \"time\";\n    editableInputTypes[\"url\"] = \"url\";\n    editableInputTypes[\"week\"] = \"week\";\n    return editableInputTypes;\n}(editableInputTypes || {});\nfunction isEditableInputOrTextArea(element) {\n    return isElementType(element, 'textarea') || isElementType(element, 'input') && element.type in editableInputTypes;\n}\n\nexport { isEditable, isEditableInputOrTextArea };\n", "import { isClickableInput } from '../click/isClickableInput.js';\nimport { isEditableInputOrTextArea } from '../edit/isEditable.js';\n\n/**\n * Determine if the element has its own selection implementation\n * and does not interact with the Document Selection API.\n */ function hasOwnSelection(node) {\n    return isElement(node) && isEditableInputOrTextArea(node);\n}\nfunction hasNoSelection(node) {\n    return isElement(node) && isClickableInput(node);\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\n\nexport { hasNoSelection, hasOwnSelection };\n", "const UIValue = Symbol('Displayed value in UI');\nconst UISelection = Symbol('Displayed selection in UI');\nconst InitialValue = Symbol('Initial value to compare on blur');\nfunction isUIValue(value) {\n    return typeof value === 'object' && UIValue in value;\n}\nfunction isUISelectionStart(start) {\n    return !!start && typeof start === 'object' && UISelection in start;\n}\nfunction setUIValue(element, value) {\n    if (element[InitialValue] === undefined) {\n        element[InitialValue] = element.value;\n    }\n    element[UIValue] = value;\n    // eslint-disable-next-line no-new-wrappers\n    element.value = Object.assign(new String(value), {\n        [UIValue]: true\n    });\n}\nfunction getUIValue(element) {\n    return element[UIValue] === undefined ? element.value : String(element[UIValue]);\n}\n/** Flag the IDL value as clean. This does not change the value.*/ function setUIValueClean(element) {\n    element[UIValue] = undefined;\n}\nfunction clearInitialValue(element) {\n    element[InitialValue] = undefined;\n}\nfunction getInitialValue(element) {\n    return element[InitialValue];\n}\nfunction setUISelectionRaw(element, selection) {\n    element[UISelection] = selection;\n}\nfunction setUISelection(element, { focusOffset: focusOffsetParam, anchorOffset: anchorOffsetParam = focusOffsetParam }, mode = 'replace') {\n    const valueLength = getUIValue(element).length;\n    const sanitizeOffset = (o)=>Math.max(0, Math.min(valueLength, o));\n    const anchorOffset = mode === 'replace' || element[UISelection] === undefined ? sanitizeOffset(anchorOffsetParam) : element[UISelection].anchorOffset;\n    const focusOffset = sanitizeOffset(focusOffsetParam);\n    const startOffset = Math.min(anchorOffset, focusOffset);\n    const endOffset = Math.max(anchorOffset, focusOffset);\n    element[UISelection] = {\n        anchorOffset,\n        focusOffset\n    };\n    if (element.selectionStart === startOffset && element.selectionEnd === endOffset) {\n        return;\n    }\n    // eslint-disable-next-line no-new-wrappers\n    const startObj = Object.assign(new Number(startOffset), {\n        [UISelection]: true\n    });\n    try {\n        element.setSelectionRange(startObj, endOffset);\n    } catch  {\n    // DOMException for invalid state is expected when calling this\n    // on an element without support for setSelectionRange\n    }\n}\nfunction getUISelection(element) {\n    var _element_selectionStart, _element_selectionEnd, _element_UISelection;\n    const sel = (_element_UISelection = element[UISelection]) !== null && _element_UISelection !== undefined ? _element_UISelection : {\n        anchorOffset: (_element_selectionStart = element.selectionStart) !== null && _element_selectionStart !== undefined ? _element_selectionStart : 0,\n        focusOffset: (_element_selectionEnd = element.selectionEnd) !== null && _element_selectionEnd !== undefined ? _element_selectionEnd : 0\n    };\n    return {\n        ...sel,\n        startOffset: Math.min(sel.anchorOffset, sel.focusOffset),\n        endOffset: Math.max(sel.anchorOffset, sel.focusOffset)\n    };\n}\nfunction hasUISelection(element) {\n    return !!element[UISelection];\n}\n/** Flag the IDL selection as clean. This does not change the selection. */ function setUISelectionClean(element) {\n    element[UISelection] = undefined;\n}\n\nexport { clearInitialValue, getInitialValue, getUISelection, getUIValue, hasUISelection, isUISelectionStart, isUIValue, setUISelection, setUISelectionClean, setUISelectionRaw, setUIValue, setUIValueClean };\n", "import { getUISelection } from '../../document/UI.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport { getContentEditable } from '../../utils/edit/isContentEditable.js';\nimport { hasOwnSelection } from '../../utils/focus/selection.js';\n\n/**\n * Determine which selection logic and selection ranges to consider.\n */ function getTargetTypeAndSelection(node) {\n    const element = getElement(node);\n    if (element && hasOwnSelection(element)) {\n        return {\n            type: 'input',\n            selection: getUISelection(element)\n        };\n    }\n    const selection = element === null || element === undefined ? undefined : element.ownerDocument.getSelection();\n    // It is possible to extend a single-range selection into a contenteditable.\n    // This results in the range acting like a range outside of contenteditable.\n    const isCE = getContentEditable(node) && (selection === null || selection === undefined ? undefined : selection.anchorNode) && getContentEditable(selection.anchorNode);\n    return {\n        type: isCE ? 'contenteditable' : 'default',\n        selection\n    };\n}\nfunction getElement(node) {\n    return node.nodeType === 1 ? node : node.parentElement;\n}\n\nexport { getTargetTypeAndSelection };\n", "import { setUISelection } from '../../document/UI.js';\nimport '../../utils/dataTransfer/Clipboard.js';\nimport { getTargetTypeAndSelection } from './getTargetTypeAndSelection.js';\n\n/**\n * Set the selection\n */ function setSelection({ focusNode, focusOffset, anchorNode = focusNode, anchorOffset = focusOffset }) {\n    var _anchorNode_ownerDocument_getSelection, _anchorNode_ownerDocument;\n    const typeAndSelection = getTargetTypeAndSelection(focusNode);\n    if (typeAndSelection.type === 'input') {\n        return setUISelection(focusNode, {\n            anchorOffset,\n            focusOffset\n        });\n    }\n    (_anchorNode_ownerDocument = anchorNode.ownerDocument) === null || _anchorNode_ownerDocument === undefined ? undefined : (_anchorNode_ownerDocument_getSelection = _anchorNode_ownerDocument.getSelection()) === null || _anchorNode_ownerDocument_getSelection === undefined ? undefined : _anchorNode_ownerDocument_getSelection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\nexport { setSelection };\n", "import '../../utils/dataTransfer/Clipboard.js';\nimport { isContentEditable } from '../../utils/edit/isContentEditable.js';\nimport { hasOwnSelection } from '../../utils/focus/selection.js';\nimport { setSelection } from './setSelection.js';\n\n/**\n * Backward-compatible selection.\n *\n * Handles input elements and contenteditable if it only contains a single text node.\n */ function setSelectionRange(element, anchorOffset, focusOffset) {\n    var _element_firstChild;\n    if (hasOwnSelection(element)) {\n        return setSelection({\n            focusNode: element,\n            anchorOffset,\n            focusOffset\n        });\n    }\n    /* istanbul ignore else */ if (isContentEditable(element) && ((_element_firstChild = element.firstChild) === null || _element_firstChild === undefined ? undefined : _element_firstChild.nodeType) === 3) {\n        return setSelection({\n            focusNode: element.firstChild,\n            anchorOffset,\n            focusOffset\n        });\n    }\n    /* istanbul ignore next */ throw new Error('Not implemented. The result of this interaction is unreliable.');\n}\n\nexport { setSelectionRange };\n", "import { releaseAllKeys } from '../keyboard/index.js';\nimport '../utils/dataTransfer/Clipboard.js';\nimport { setSelectionRange } from '../event/selection/setSelectionRange.js';\n\nasync function type(element, text, { skipClick = this.config.skipClick, skipAutoClose = this.config.skipAutoClose, initialSelectionStart, initialSelectionEnd } = {}) {\n    // TODO: properly type guard\n    // we use this workaround for now to prevent changing behavior\n    if (element.disabled) return;\n    if (!skipClick) {\n        await this.click(element);\n    }\n    if (initialSelectionStart !== undefined) {\n        setSelectionRange(element, initialSelectionStart, initialSelectionEnd !== null && initialSelectionEnd !== undefined ? initialSelectionEnd : initialSelectionStart);\n    }\n    await this.keyboard(text);\n    if (!skipAutoClose) {\n        await releaseAllKeys(this);\n    }\n}\n\nexport { type };\n"],
  "mappings": "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",
  "names": ["bracketDict", "clickableInputTypes", "editableInputTypes", "getElement"]
}
